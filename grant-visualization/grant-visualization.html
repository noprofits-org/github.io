<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nonprofit Grant Flow Network</title>
    <style>
        body {
            margin: 0;
            background: #0f172a;
            color: white;
            font-family: sans-serif;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 4px;
            z-index: 1000;
        }
        .control-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="number"] {
            width: 100px;
            padding: 5px;
            margin-right: 10px;
        }
        button {
            background: #4299e1;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #3182ce;
        }
        #stats {
            margin-top: 10px;
            font-size: 0.9em;
        }
        .legend {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 4px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <p>Data sourced from joeisdone.github.io/charity (accessed January 2025)</p>
    <div id="controls">
        <div class="control-group">
            <label>Minimum Grant Amount ($):</label>
            <input type="number" id="minAmount" value="10000">
        </div>
        <div class="control-group">
            <label>Max Organizations to Show:</label>
            <input type="number" id="maxOrgs" value="50">
        </div>
        <button onclick="updateVisualization()">Update View</button>
        <div id="stats"></div>
    </div>
    <div class="legend">
        Circle Size: Total grant volume (given + received)<br>
        Line Thickness: Individual grant amount
    </div>
    <svg id="network" style="width:100vw; height:100vh;"></svg>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let originalData = null;

        async function loadData() {
            try {
                const [charitiesResponse, grantsResponse] = await Promise.all([
                    fetch('charities.csv'),
                    fetch('grants.csv')
                ]);
                
                const charitiesText = await charitiesResponse.text();
                const grantsText = await grantsResponse.text();
                
                return {
                    charities: d3.csvParse(charitiesText),
                    grants: d3.csvParse(grantsText)
                };
            } catch (error) {
                console.error('Error loading data:', error);
                return null;
            }
        }

        function filterData(charities, grants) {
            const minAmount = parseFloat(document.getElementById('minAmount').value);
            const maxOrgs = parseInt(document.getElementById('maxOrgs').value);

            // Filter grants by amount
            const filteredGrants = grants.filter(g => parseFloat(g.grant_amt) >= minAmount);

            // Find organizations that are part of grant relationships
            const activeOrgs = new Set();
            filteredGrants.forEach(grant => {
                activeOrgs.add(grant.filer_ein);
                activeOrgs.add(grant.grant_ein);
            });

            // Calculate total grant volume (given + received) for each organization
            const orgVolume = new Map();
            filteredGrants.forEach(grant => {
                const amount = parseFloat(grant.grant_amt);
                orgVolume.set(grant.filer_ein, (orgVolume.get(grant.filer_ein) || 0) + amount);
                orgVolume.set(grant.grant_ein, (orgVolume.get(grant.grant_ein) || 0) + amount);
            });

            // Get top organizations by volume
            const topOrgs = new Set(
                Array.from(orgVolume.entries())
                    .filter(([ein]) => activeOrgs.has(ein))
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, maxOrgs)
                    .map(([ein]) => ein)
            );

            // Filter grants to only include top organizations
            const finalGrants = filteredGrants.filter(
                grant => topOrgs.has(grant.filer_ein) && topOrgs.has(grant.grant_ein)
            );

            document.getElementById('stats').innerHTML = `
                Showing ${topOrgs.size} organizations<br>
                ${finalGrants.length} grants visible<br>
                Total grants in dataset: ${grants.length}
            `;

            return { filteredGrants: finalGrants, topOrgs };
        }

        function createVisualization(charities, grants) {
            d3.select('#network').selectAll('*').remove();

            const width = window.innerWidth;
            const height = window.innerHeight;
            const svg = d3.select('#network')
                .attr('viewBox', [0, 0, width, height]);

            // Create charity name lookup
            const charityNames = new Map(
                charities.map(d => [d.filer_ein, d.filer_name])
            );

            // Create nodes
            const uniqueEINs = new Set([
                ...grants.map(d => d.filer_ein),
                ...grants.map(d => d.grant_ein)
            ]);

            const nodes = Array.from(uniqueEINs).map(ein => ({
                id: ein,
                name: charityNames.get(ein) || 'Unknown Organization',
                ein: ein
            }));

            // Create links
            const links = grants.map(d => ({
                source: d.filer_ein,
                target: d.grant_ein,
                value: +d.grant_amt
            }));

            // Calculate node sizes based on total grant volume
            const grantVolume = new Map();
            grants.forEach(grant => {
                const amount = +grant.grant_amt;
                grantVolume.set(grant.filer_ein, (grantVolume.get(grant.filer_ein) || 0) + amount);
                grantVolume.set(grant.grant_ein, (grantVolume.get(grant.grant_ein) || 0) + amount);
            });

            nodes.forEach(node => {
                const volume = grantVolume.get(node.id) || 0;
                node.value = Math.sqrt(volume) / 10000; // Reduced scaling factor for smaller bubbles
            });

            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2));

            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .style('stroke', '#64748b')
                .style('stroke-opacity', 0.6)
                .style('stroke-width', d => Math.sqrt(d.value) / 10000); // Reduced scaling

            const node = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .call(drag(simulation));

            node.append('circle')
                .attr('r', d => Math.max(3, d.value * 10)) // Minimum size 3, reduced scaling
                .style('fill', '#4299e1')
                .style('stroke', '#2b6cb0')
                .style('stroke-width', 1.5);

            // Add labels with both name and EIN
            node.append('text')
                .text(d => `${d.name} (${d.ein})`)
                .attr('x', d => Math.max(3, d.value * 10) + 5)
                .attr('y', 3)
                .style('fill', 'white')
                .style('font-size', '8px')
                .style('pointer-events', 'none');

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });

            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                   // event.subject.fx = null;
                   // event.subject.fy = null;
                }

                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            }
        }

        async function updateVisualization() {
            if (!originalData) {
                originalData = await loadData();
            }
            
            if (originalData) {
                const { filteredGrants, topOrgs } = filterData(
                    originalData.charities,
                    originalData.grants
                );
                createVisualization(originalData.charities, filteredGrants);
            }
        }

        window.addEventListener('load', updateVisualization);
    </script>
</body>
</html>